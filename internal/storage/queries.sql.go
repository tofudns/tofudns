// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createOTP = `-- name: CreateOTP :one

INSERT INTO otp_codes (
    email,
    code,
    expires_at
) VALUES (
    $1, $2, $3
) RETURNING id, email, code, expires_at, consumed_at, created_at
`

type CreateOTPParams struct {
	Email     string
	Code      string
	ExpiresAt time.Time
}

// OTP Authentication Queries
func (q *Queries) CreateOTP(ctx context.Context, arg CreateOTPParams) (OtpCode, error) {
	row := q.db.QueryRowContext(ctx, createOTP, arg.Email, arg.Code, arg.ExpiresAt)
	var i OtpCode
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Code,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createRecord = `-- name: CreateRecord :one
INSERT INTO coredns_records (
    user_id,
    zone,
    name,
    ttl,
    content,
    record_type
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, zone, name, ttl, content, record_type
`

type CreateRecordParams struct {
	UserID     uuid.UUID
	Zone       string
	Name       string
	Ttl        sql.NullInt32
	Content    sql.NullString
	RecordType string
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (CorednsRecord, error) {
	row := q.db.QueryRowContext(ctx, createRecord,
		arg.UserID,
		arg.Zone,
		arg.Name,
		arg.Ttl,
		arg.Content,
		arg.RecordType,
	)
	var i CorednsRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Name,
		&i.Ttl,
		&i.Content,
		&i.RecordType,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email
) VALUES (
    $1
) RETURNING id, email, created_at, updated_at
`

func (q *Queries) CreateUser(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecord = `-- name: DeleteRecord :exec
DELETE FROM coredns_records
WHERE id = $1 AND zone = $2 AND user_id = $3
`

type DeleteRecordParams struct {
	ID     int64
	Zone   string
	UserID uuid.UUID
}

func (q *Queries) DeleteRecord(ctx context.Context, arg DeleteRecordParams) error {
	_, err := q.db.ExecContext(ctx, deleteRecord, arg.ID, arg.Zone, arg.UserID)
	return err
}

const getLatestOTPByEmail = `-- name: GetLatestOTPByEmail :one
SELECT id, email, code, expires_at, consumed_at, created_at FROM otp_codes
WHERE email = $1 AND consumed_at IS NULL AND expires_at > NOW()
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestOTPByEmail(ctx context.Context, email string) (OtpCode, error) {
	row := q.db.QueryRowContext(ctx, getLatestOTPByEmail, email)
	var i OtpCode
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Code,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRecordByID = `-- name: GetRecordByID :one
SELECT id, user_id, zone, name, ttl, content, record_type FROM coredns_records
WHERE id = $1 AND zone = $2 AND user_id = $3
`

type GetRecordByIDParams struct {
	ID     int64
	Zone   string
	UserID uuid.UUID
}

// Records Queries
func (q *Queries) GetRecordByID(ctx context.Context, arg GetRecordByIDParams) (CorednsRecord, error) {
	row := q.db.QueryRowContext(ctx, getRecordByID, arg.ID, arg.Zone, arg.UserID)
	var i CorednsRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Name,
		&i.Ttl,
		&i.Content,
		&i.RecordType,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, created_at, updated_at FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, created_at, updated_at FROM users
WHERE id = $1
`

// User Queries
func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRecords = `-- name: ListRecords :many
SELECT id, user_id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1 AND user_id = $2
ORDER BY name, record_type
`

type ListRecordsParams struct {
	Zone   string
	UserID uuid.UUID
}

func (q *Queries) ListRecords(ctx context.Context, arg ListRecordsParams) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecords, arg.Zone, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByName = `-- name: ListRecordsByName :many
SELECT id, user_id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1 AND name = $2 AND user_id = $3
ORDER BY id
`

type ListRecordsByNameParams struct {
	Zone   string
	Name   string
	UserID uuid.UUID
}

func (q *Queries) ListRecordsByName(ctx context.Context, arg ListRecordsByNameParams) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsByName, arg.Zone, arg.Name, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByType = `-- name: ListRecordsByType :many
SELECT id, user_id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1 AND record_type = $2 AND user_id = $3
ORDER BY name
`

type ListRecordsByTypeParams struct {
	Zone       string
	RecordType string
	UserID     uuid.UUID
}

func (q *Queries) ListRecordsByType(ctx context.Context, arg ListRecordsByTypeParams) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsByType, arg.Zone, arg.RecordType, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByZone = `-- name: ListRecordsByZone :many
SELECT id, user_id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1 AND user_id = $2
ORDER BY name, record_type
`

type ListRecordsByZoneParams struct {
	Zone   string
	UserID uuid.UUID
}

func (q *Queries) ListRecordsByZone(ctx context.Context, arg ListRecordsByZoneParams) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsByZone, arg.Zone, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listZones = `-- name: ListZones :many
SELECT DISTINCT zone 
FROM coredns_records 
WHERE user_id = $1
ORDER BY zone
`

func (q *Queries) ListZones(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listZones, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var zone string
		if err := rows.Scan(&zone); err != nil {
			return nil, err
		}
		items = append(items, zone)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecord = `-- name: UpdateRecord :one
UPDATE coredns_records
SET 
    name = $2,
    ttl = $3,
    content = $4,
    record_type = $5
WHERE id = $1 AND zone = $6 AND user_id = $7
RETURNING id, user_id, zone, name, ttl, content, record_type
`

type UpdateRecordParams struct {
	ID         int64
	Name       string
	Ttl        sql.NullInt32
	Content    sql.NullString
	RecordType string
	Zone       string
	UserID     uuid.UUID
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (CorednsRecord, error) {
	row := q.db.QueryRowContext(ctx, updateRecord,
		arg.ID,
		arg.Name,
		arg.Ttl,
		arg.Content,
		arg.RecordType,
		arg.Zone,
		arg.UserID,
	)
	var i CorednsRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Name,
		&i.Ttl,
		&i.Content,
		&i.RecordType,
	)
	return i, err
}

const validateAndConsumeOTP = `-- name: ValidateAndConsumeOTP :one
UPDATE otp_codes
SET consumed_at = NOW()
WHERE id = (
    SELECT otp_codes.id FROM otp_codes
    WHERE otp_codes.email = $1 AND otp_codes.code = $2 AND otp_codes.consumed_at IS NULL AND otp_codes.expires_at > NOW()
    ORDER BY otp_codes.created_at DESC
    LIMIT 1
)
RETURNING id, email, code, expires_at, consumed_at, created_at
`

type ValidateAndConsumeOTPParams struct {
	Email string
	Code  string
}

func (q *Queries) ValidateAndConsumeOTP(ctx context.Context, arg ValidateAndConsumeOTPParams) (OtpCode, error) {
	row := q.db.QueryRowContext(ctx, validateAndConsumeOTP, arg.Email, arg.Code)
	var i OtpCode
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Code,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}
