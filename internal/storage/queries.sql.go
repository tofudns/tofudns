// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
)

const createRecord = `-- name: CreateRecord :one
INSERT INTO coredns_records (
    zone,
    name,
    ttl,
    content,
    record_type
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, zone, name, ttl, content, record_type
`

type CreateRecordParams struct {
	Zone       string
	Name       string
	Ttl        sql.NullInt32
	Content    sql.NullString
	RecordType string
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (CorednsRecord, error) {
	row := q.db.QueryRowContext(ctx, createRecord,
		arg.Zone,
		arg.Name,
		arg.Ttl,
		arg.Content,
		arg.RecordType,
	)
	var i CorednsRecord
	err := row.Scan(
		&i.ID,
		&i.Zone,
		&i.Name,
		&i.Ttl,
		&i.Content,
		&i.RecordType,
	)
	return i, err
}

const deleteRecord = `-- name: DeleteRecord :exec
DELETE FROM coredns_records
WHERE id = $1 AND zone = $2
`

type DeleteRecordParams struct {
	ID   int64
	Zone string
}

func (q *Queries) DeleteRecord(ctx context.Context, arg DeleteRecordParams) error {
	_, err := q.db.ExecContext(ctx, deleteRecord, arg.ID, arg.Zone)
	return err
}

const getRecordByID = `-- name: GetRecordByID :one
SELECT id, zone, name, ttl, content, record_type FROM coredns_records
WHERE id = $1 AND zone = $2
`

type GetRecordByIDParams struct {
	ID   int64
	Zone string
}

func (q *Queries) GetRecordByID(ctx context.Context, arg GetRecordByIDParams) (CorednsRecord, error) {
	row := q.db.QueryRowContext(ctx, getRecordByID, arg.ID, arg.Zone)
	var i CorednsRecord
	err := row.Scan(
		&i.ID,
		&i.Zone,
		&i.Name,
		&i.Ttl,
		&i.Content,
		&i.RecordType,
	)
	return i, err
}

const listRecords = `-- name: ListRecords :many
SELECT id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1
ORDER BY name, record_type
`

func (q *Queries) ListRecords(ctx context.Context, zone string) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecords, zone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByName = `-- name: ListRecordsByName :many
SELECT id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1 AND name = $2
ORDER BY id
`

type ListRecordsByNameParams struct {
	Zone string
	Name string
}

func (q *Queries) ListRecordsByName(ctx context.Context, arg ListRecordsByNameParams) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsByName, arg.Zone, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByType = `-- name: ListRecordsByType :many
SELECT id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1 AND record_type = $2
ORDER BY name
`

type ListRecordsByTypeParams struct {
	Zone       string
	RecordType string
}

func (q *Queries) ListRecordsByType(ctx context.Context, arg ListRecordsByTypeParams) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsByType, arg.Zone, arg.RecordType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByZone = `-- name: ListRecordsByZone :many
SELECT id, zone, name, ttl, content, record_type FROM coredns_records
WHERE zone = $1
ORDER BY name, record_type
`

func (q *Queries) ListRecordsByZone(ctx context.Context, zone string) ([]CorednsRecord, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsByZone, zone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorednsRecord
	for rows.Next() {
		var i CorednsRecord
		if err := rows.Scan(
			&i.ID,
			&i.Zone,
			&i.Name,
			&i.Ttl,
			&i.Content,
			&i.RecordType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listZones = `-- name: ListZones :many
SELECT DISTINCT zone 
FROM coredns_records 
ORDER BY zone
`

func (q *Queries) ListZones(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listZones)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var zone string
		if err := rows.Scan(&zone); err != nil {
			return nil, err
		}
		items = append(items, zone)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecord = `-- name: UpdateRecord :one
UPDATE coredns_records
SET 
    name = $2,
    ttl = $3,
    content = $4,
    record_type = $5
WHERE id = $1 AND zone = $6
RETURNING id, zone, name, ttl, content, record_type
`

type UpdateRecordParams struct {
	ID         int64
	Name       string
	Ttl        sql.NullInt32
	Content    sql.NullString
	RecordType string
	Zone       string
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (CorednsRecord, error) {
	row := q.db.QueryRowContext(ctx, updateRecord,
		arg.ID,
		arg.Name,
		arg.Ttl,
		arg.Content,
		arg.RecordType,
		arg.Zone,
	)
	var i CorednsRecord
	err := row.Scan(
		&i.ID,
		&i.Zone,
		&i.Name,
		&i.Ttl,
		&i.Content,
		&i.RecordType,
	)
	return i, err
}
